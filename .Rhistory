select(-alcohol_involved)
parties <- parties %>%
# Select only relevant variables
select(case_id, party_number, party_type, dir_of_travel, move_pre_acc) %>%
# Filter for parties that are in the collision table
filter(case_id %in% collisions$case_id) %>%
# Join collisions to party table
left_join(collisions) %>%
# Group by Case ID,
group_by(case_id) %>%
# Select only those case IDs where there was at least one person making a 'U' or 'L' turn
filter(any(move_pre_acc %in% c('E','F'))) %>%
filter(n() >= 2) %>%
ungroup()
# mutate(count = n()) %>%
# ungroup()
### Script for Left-Turn Prioritization ###
# Load Libraries
library(tidyverse)
# Import Data
collisions <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/switrs_los_angeles20180112.csv')
parties <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/party_los_angeles20180112.csv')
candidate_int <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/Vision Zero Signals - LT Crash Analysis.csv')
# Clean and Reformat Data Tables
candidate_int <- candidate_int %>%
select(Int, Primary.Street, X.Street, Phasing.Type, Phasing.Direction.s.)
collisions <- collisions %>%
# select only relevant variables
select(case_id, accident_year, collision_severity, alcohol_involved, int_id) %>%
# only last five full years of data (2012-2016)
filter(accident_year >= 2012 & accident_year <= 2016) %>%
# filter for KSIs
filter(collision_severity %in% c(1,2)) %>%
# remove any collisions where alcohol was involved
filter(alcohol_involved != 'Y') %>%
# only intersted in collision history at candidate locations
filter(int_id %in% candidate_int$Int) %>%
# also remove collisions without an assigned intersection
filter(!is.na(int_id)) %>%
# drop alcohol_involved variable after filter
select(-alcohol_involved)
parties <- parties %>%
# Select only relevant variables
select(case_id, party_number, party_type, dir_of_travel, move_pre_acc) %>%
# Filter for parties that are in the collision table
filter(case_id %in% collisions$case_id) %>%
# Join collisions to party table
left_join(collisions) %>%
# Group by Case ID,
group_by(case_id) %>%
# Select only those case IDs where there was at least one person making a 'U' or 'L' turn
filter(any(move_pre_acc %in% c('E','F'))) %>%
# Select only collisions involving at least two parties
filter(n() >= 2) %>%
ungroup() %>%
# Filter again
filter(move_pre_acc %in% c('E','F')) %>%
group_by(int_id, dir_of_travel) %>%
summarise(ct = n())
write.csv(parties)
### Script for Left-Turn Prioritization ###
# Load Libraries
library(tidyverse)
# Import Data
collisions <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/switrs_los_angeles20180112.csv')
parties <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/party_los_angeles20180112.csv')
candidate_int <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/Vision Zero Signals - LT Crash Analysis.csv')
# Clean and Reformat Data Tables
candidate_int <- candidate_int %>%
select(Int, Primary.Street, X.Street, Phasing.Type, Phasing.Direction.s.)
collisions <- collisions %>%
# select only relevant variables
select(case_id, accident_year, collision_severity, alcohol_involved, int_id) %>%
# only last five full years of data (2012-2016)
filter(accident_year >= 2012 & accident_year <= 2016) %>%
# remove any collisions where alcohol was involved
filter(alcohol_involved != 'Y') %>%
# only intersted in collision history at candidate locations
filter(int_id %in% candidate_int$Int) %>%
# also remove collisions without an assigned intersection
filter(!is.na(int_id)) %>%
# drop alcohol_involved variable after filter
select(-alcohol_involved)
ksi_collisions <- collisions %>%
filter(collision_severity %in% c(1,2))
parties <- parties %>%
# Select only relevant variables
select(case_id, party_number, party_type, dir_of_travel, move_pre_acc) %>%
# Filter for parties that are in the collision table
filter(case_id %in% collisions$case_id) %>%
# Group by Case ID,
group_by(case_id) %>%
# Select only those case IDs where there was at least one person making a 'U' or 'L' turn
filter(any(move_pre_acc %in% c('E','F'))) %>%
# Select only collisions involving at least two parties
filter(n() >= 2) %>%
ungroup()
ksi_count <- parties %>%
# Filter for KSIs
filter(collision_severity %in% c(1,2))
# Filter by movement again
filter(move_pre_acc %in% c('E','F')) %>%
group_by(int_id, dir_of_travel) %>%
summarise(ct = n())
ksi_count <- parties %>%
# Filter for KSIs
filter(collision_severity %in% c(1,2)) %>%
# Filter by movement again
filter(move_pre_acc %in% c('E','F')) %>%
group_by(int_id, dir_of_travel) %>%
summarise(ct = n())
### Script for Left-Turn Prioritization ###
# Load Libraries
library(tidyverse)
# Import Data
collisions <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/switrs_los_angeles20180112.csv')
parties <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/party_los_angeles20180112.csv')
candidate_int <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/Vision Zero Signals - LT Crash Analysis.csv')
# Clean and Reformat Data Tables
candidate_int <- candidate_int %>%
select(Int, Primary.Street, X.Street, Phasing.Type, Phasing.Direction.s.)
collisions <- collisions %>%
# select only relevant variables
select(case_id, accident_year, collision_severity, alcohol_involved, int_id) %>%
# only last five full years of data (2012-2016)
filter(accident_year >= 2012 & accident_year <= 2016) %>%
# remove any collisions where alcohol was involved
filter(alcohol_involved != 'Y') %>%
# only intersted in collision history at candidate locations
filter(int_id %in% candidate_int$Int) %>%
# also remove collisions without an assigned intersection
filter(!is.na(int_id)) %>%
# drop alcohol_involved variable after filter
select(-alcohol_involved)
ksi_collisions <- collisions %>%
filter(collision_severity %in% c(1,2))
parties <- parties %>%
# Select only relevant variables
select(case_id, party_number, party_type, dir_of_travel, move_pre_acc) %>%
# Filter for parties that are in the collision table
filter(case_id %in% collisions$case_id) %>%
# Join to collision table to get collision_severity
left_join(collisions)
# Group by Case ID,
group_by(case_id) %>%
# Select only those case IDs where there was at least one person making a 'U' or 'L' turn
filter(any(move_pre_acc %in% c('E','F'))) %>%
# Select only collisions involving at least two parties
filter(n() >= 2) %>%
ungroup()
ksi_count <- parties %>%
# Filter for KSIs
filter(collision_severity %in% c(1,2)) %>%
# Filter by movement again
filter(move_pre_acc %in% c('E','F')) %>%
group_by(int_id, dir_of_travel) %>%
summarise(ct = n())
### Script for Left-Turn Prioritization ###
# Load Libraries
library(tidyverse)
# Import Data
collisions <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/switrs_los_angeles20180112.csv')
parties <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/party_los_angeles20180112.csv')
candidate_int <- read.csv('Z:/VisionZero/GIS/Projects/2018-01_LeftTurnPhasingPrioritization/Data/Vision Zero Signals - LT Crash Analysis.csv')
# Clean and Reformat Data Tables
candidate_int <- candidate_int %>%
select(Int, Primary.Street, X.Street, Phasing.Type, Phasing.Direction.s.)
collisions <- collisions %>%
# select only relevant variables
select(case_id, accident_year, collision_severity, alcohol_involved, int_id) %>%
# only last five full years of data (2012-2016)
filter(accident_year >= 2012 & accident_year <= 2016) %>%
# remove any collisions where alcohol was involved
filter(alcohol_involved != 'Y') %>%
# only intersted in collision history at candidate locations
filter(int_id %in% candidate_int$Int) %>%
# also remove collisions without an assigned intersection
filter(!is.na(int_id)) %>%
# drop alcohol_involved variable after filter
select(-alcohol_involved)
ksi_collisions <- collisions %>%
filter(collision_severity %in% c(1,2))
parties <- parties %>%
# Select only relevant variables
select(case_id, party_number, party_type, dir_of_travel, move_pre_acc) %>%
# Filter for parties that are in the collision table
filter(case_id %in% collisions$case_id) %>%
# Join to collision table to get collision_severity
left_join(collisions) %>%
# Group by Case ID,
group_by(case_id) %>%
# Select only those case IDs where there was at least one person making a 'U' or 'L' turn
filter(any(move_pre_acc %in% c('E','F'))) %>%
# Select only collisions involving at least two parties
filter(n() >= 2) %>%
ungroup()
ksi_count <- parties %>%
# Filter for KSIs
filter(collision_severity %in% c(1,2)) %>%
# Filter by movement again
filter(move_pre_acc %in% c('E','F')) %>%
group_by(int_id, dir_of_travel) %>%
summarise(ct = n())
View(ksi_count)
ksi_count <- parties %>%
# Filter for KSIs
filter(collision_severity %in% c(1,2)) %>%
# Filter by movement again
filter(move_pre_acc %in% c('E','F')) %>%
group_by(int_id, dir_of_travel) %>%
summarise(ksi.ct = n())
col_count <- parties %>%
filter(move_pre_acc %in% c('E','F')) %>%
group_by(int_id, dir_of_travel) %>%
summarise(col.ct = n())
View(col_count)
inj_count <- parties %>%
# Filter for KSIs
filter(collision_severity %in% c(1,2,3,4)) %>%
# Filter by movement again
filter(move_pre_acc %in% c('E','F')) %>%
group_by(int_id, dir_of_travel) %>%
summarise(inj.ct = n())
View(inj_count)
sum(ksi_count$ksi.ct)
shiny::runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_points)
View(lafd_log)
View(lafd_points)
View(lafd_log)
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_log)
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_log)
View(lafd_log)
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_log)
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_paths)
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_paths)
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_paths)
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
a <- c(1,2,3)
b <- c(3,4,5)
a + b
shiny::runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_paths)
View(lafd_paths)
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_paths)
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_log)
lafd_log
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_log)
print(lafd_log)
glimplse(lafd_log)
glimpse(lafd_log)
runApp()
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_log)
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_log)
runApp('GitHub/Jonathans-Utilities/TPS')
View(lafd_paths)
shiny::runApp('GitHub/vzcd-shiny/app/VZ_Viewer')
# load libraries
library(sf)
library(dplyr)
library(leaflet)
library(units)
# import street data
caltrans <- st_read("Data/CaltransCenterlineD07_LACityClip.shp")
```{r}
calltrans_filtered <- caltrans %>%
select(
FULLNAME,
FC_DRAFT) %>%
filter(FC_DRAFT == 3) %>%
# Group & Merge by
group_by(FULLNAME) %>%
summarize() %>%
# Cast sfc_geometry mix to sfc_multilinestring
st_cast() %>%
# Select only those with a length > 1/4 mi (402.336m)
filter(st_length(.) > set_units(402.336, m))
# need to add st_line_merge to aggregate blocks up into segments
caltrans_merge <- st_line_merge(calltrans_filtered)
leaflet() %>%
addTiles() %>%
addPolylines(data=caltrans_merge)
st_write(caltrans_merge, 'caltrans_major.shp')
# load libraries
library(sf)
library(dplyr)
library(leaflet)
library(units)
# import street data
caltrans <- st_read("Data/CaltransCenterlineD07_LACityClip.shp")
calltrans_filtered <- caltrans %>%
select(
FULLNAME,
FC_DRAFT) %>%
filter(FC_DRAFT == 3) %>%
# Group & Merge by
group_by(FULLNAME) %>%
summarize() %>%
# Cast sfc_geometry mix to sfc_multilinestring
st_cast() %>%
# Select only those with a length > 1/4 mi (402.336m)
filter(st_length(.) > set_units(402.336, m))
# need to add st_line_merge to aggregate blocks up into segments
caltrans_merge <- st_line_merge(calltrans_filtered)
leaflet() %>%
addTiles() %>%
addPolylines(data=caltrans_merge)
st_write(caltrans_merge, 'caltrans_major.shp')
st_write(caltrans_merge, 'caltrans__major.shp')
shiny::runApp('GitHub/vzcd-shiny/app/VZ_Viewer')
install.packages("mapedit")
library(mapedit)
library(leaflet)
library(mapview)
editMap(leaflet() %>% addTiles())
editMap(
mapview(breweries91),
targetLayerId = "breweries91"
)
shiny::runApp('GitHub/vzcd-shiny/app/VZ_Viewer')
shiny::runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
install.packages('plumber')
library(plumber)
r <- plumb('C:\Users\dotcid034\Documents\R_TestScripts\mailgun_test.R')
r <- plump('C:/Users/dotcid034/Documents/R_TestScripts/mailgun_test.R')
r <- plumb('C:/Users/dotcid034/Documents/R_TestScripts/mailgun_test.R')
r$run(port=8000)
install.packages('analogsea')
shiny::runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
library(sf)
library(dplyr)
library(httr)
# MO Codes
ped_inv_codes = '3003'
bike_inv_codes = c('3008', '3016', '3017', '3018')
mc_inv_codes = c('3009', '3013', '3014', '3015')
hit_and_run_codes = c('3029', '3030')
# Current Plan: Download only 2018 data (so there is not too much in memory)
# Next steps: Download entire dataset by (1) get length and (2) set limit to length and (3) save to Spatialite & query Spatialite
# sqlite would be better when I setup a container
# Access socrata api for collisions
# Metadata URL https://data.lacity.org/api/views/metadata/v1/k8cc-2d49
# Step 1: need to access the socrata API to get the length - number of records
response <- GET('https://data.lacity.org/resource/k8cc-2d49.json?$select=count(dr_no)')
record_ct <- content(response, 'parsed')[[1]][[1]]
# Step 2: make the request
#request = paste0('https://data.lacity.org/resource/k8cc-2d49.geojson?$limit=',record_ct)
#collisions = read_sf(request)
# Step 1&2 (current): Query for collisions since this year, with no limit
request = paste0('https://data.lacity.org/resource/k8cc-2d49.geojson?$where=date_extract_y(date_occ)=2018&$limit=',record_ct)
collisions = read_sf(request)
# Step 3: Clean MO Codes
collisions <- collisions %>%
# rowwise() makes sure that the mutate operations don't use data from the entire df
rowwise() %>%
mutate(severity = case_when(grepl('3027',mocodes) ~ 1,
grepl('3024',mocodes) ~ 2,
grepl('3025',mocodes) ~ 3,
grepl('3026',mocodes) ~ 4,
grepl('3028',mocodes) ~ 0)) %>%
mutate(mode = case_when(any(sapply(ped_inv_codes, grepl, mocodes)) ~ 'Ped',
any(sapply(bike_inv_codes, grepl, mocodes)) ~ 'Bike',
any(sapply(mc_inv_codes, grepl, mocodes)) ~ 'MC')) %>%
mutate(hit_and_run = ifelse(any(sapply(hit_and_run_codes, grepl, mocodes)),'Y',NA)) %>%
# remove rowwise operation
ungroup() %>%
# recast as sf object
st_sf()
# Export to geojson (future will dump to sqlite + spatailite)
write_sf(collisions, 'data/lapd_collisions/collisions.geojson')
View(collisions)
runApp('GitHub/vzcd-shiny')
traceback()
runApp('GitHub/vzcd-shiny')
runApp('GitHub/vzcd-shiny')
lapd_collisions <- read_sf('data/lapd_collisions/collisions.geojson')
hin <- read_sf('data/High_Injury_Network.geojson')
pc <- read_sf('data/prioritized_corridors/pc_05232017_wgs84_.shp')
get_wd()
getwd()
setwd("~/GitHub/vzcd-shiny")
highvis_xwalks <- read_sf('data/crosswalks/crosswalks.shp')
lpi <- read_sf('data/lpi/lpi.shp')
paddle_signs <- read_sf('data/paddle_signs/paddle_signs.shp')
pafb <- read_sf('data/pafb/pafb.shp')
ped_islands <- read_sf('data/ped_islands/ped_islands.shp')
scrambles <- read_sf('data/scrambles/scrambles.shp')
int_tight <- read_sf('data/int_tightening/int_tightening.shp')
highvis_xwalks2 <- highvis_xwalks %>% select() %>% mutate(Type = 'High-Visibility Crosswalk')
lpi2 <- lpi %>% select() %>% mutate(Type = 'Leading Pedestrian Interval')
paddle_signs2 <- paddle_signs %>% select() %>% mutate(Type = 'Paddle Sign')
pafb2 <- pafb %>% select() %>% mutate(Type = 'Pedestrian-Activated Flashing Beacon')
ped_islands2 <- ped_islands %>% select() %>% mutate(Type = 'Pedestrian Island')
scrambles2 <- scrambles %>% select() %>% mutate(Type = 'Scramble Crosswalk')
int_tight2 <- int_tight %>% select() %>% mutate(Type = 'Interim Intersection Tightening')
infrastructure <- rbind(highvis_xwalks2, lpi2, paddle_signs2, pafb2, ped_islands2, scrambles2, int_tight2)
infrastructure <- infrastructure %>% mutate(Type = as.factor(Type))
getwd()
highvis_xwalks <- read_sf('data/crosswalks/crosswalks.shp')
library(sf)
# Infrastructure
highvis_xwalks <- read_sf('data/crosswalks/crosswalks.shp')
lpi <- read_sf('data/lpi/lpi.shp')
paddle_signs <- read_sf('data/paddle_signs/paddle_signs.shp')
pafb <- read_sf('data/pafb/pafb.shp')
ped_islands <- read_sf('data/ped_islands/ped_islands.shp')
scrambles <- read_sf('data/scrambles/scrambles.shp')
int_tight <- read_sf('data/int_tightening/int_tightening.shp')
highvis_xwalks2 <- highvis_xwalks %>% select() %>% mutate(Type = 'High-Visibility Crosswalk')
lpi2 <- lpi %>% select() %>% mutate(Type = 'Leading Pedestrian Interval')
paddle_signs2 <- paddle_signs %>% select() %>% mutate(Type = 'Paddle Sign')
pafb2 <- pafb %>% select() %>% mutate(Type = 'Pedestrian-Activated Flashing Beacon')
ped_islands2 <- ped_islands %>% select() %>% mutate(Type = 'Pedestrian Island')
scrambles2 <- scrambles %>% select() %>% mutate(Type = 'Scramble Crosswalk')
int_tight2 <- int_tight %>% select() %>% mutate(Type = 'Interim Intersection Tightening')
infrastructure <- rbind(highvis_xwalks2, lpi2, paddle_signs2, pafb2, ped_islands2, scrambles2, int_tight2)
infrastructure <- infrastructure %>% mutate(Type = as.factor(Type))
##### Setup
library(shinydashboard)
library(leaflet)
library(dplyr)
library(curl)
library(sp)
library(rgeos)
library(sf)
library(mapview)
library(webshot)
library(htmlwidgets)
library(units)
library(xtable)
library(gmodels)
library(rgdal)
library(tidyr)
library(ggplot2)
# Infrastructure
highvis_xwalks <- read_sf('data/crosswalks/crosswalks.shp')
lpi <- read_sf('data/lpi/lpi.shp')
paddle_signs <- read_sf('data/paddle_signs/paddle_signs.shp')
pafb <- read_sf('data/pafb/pafb.shp')
ped_islands <- read_sf('data/ped_islands/ped_islands.shp')
scrambles <- read_sf('data/scrambles/scrambles.shp')
int_tight <- read_sf('data/int_tightening/int_tightening.shp')
highvis_xwalks2 <- highvis_xwalks %>% select() %>% mutate(Type = 'High-Visibility Crosswalk')
lpi2 <- lpi %>% select() %>% mutate(Type = 'Leading Pedestrian Interval')
paddle_signs2 <- paddle_signs %>% select() %>% mutate(Type = 'Paddle Sign')
pafb2 <- pafb %>% select() %>% mutate(Type = 'Pedestrian-Activated Flashing Beacon')
ped_islands2 <- ped_islands %>% select() %>% mutate(Type = 'Pedestrian Island')
scrambles2 <- scrambles %>% select() %>% mutate(Type = 'Scramble Crosswalk')
int_tight2 <- int_tight %>% select() %>% mutate(Type = 'Interim Intersection Tightening')
infrastructure <- rbind(highvis_xwalks2, lpi2, paddle_signs2, pafb2, ped_islands2, scrambles2, int_tight2)
infrastructure <- infrastructure %>% mutate(Type = as.factor(Type))
infrastructure$Type
levels(infrastructure$Type)
shiny::runApp()
runApp()
levels(infrastructure)
levels(infrastructure$Type)
runApp()
runApp()
runApp()
colors = c('#E11F8F','#482D8B','#79BC43','#F58220','#FFC828','#008576','#96C0E6')
names(colors) = c( 'High-Visibility Crosswalk','Interim Intersection Tightening','Leading Pedestrian Interval','Paddle Sign','Pedestrian-Activated Flashing Beacon','Pedestrian Refuge Island','Scramble Crosswalk')
colors
colors[Infrastructure$Type]
colors[infrastructure$Type]
colors[unique(infrastructure$Type)]
runApp()
colors = c('#E11F8F','#482D8B','#79BC43','#F58220','#FFC828','#008576','#96C0E6')
names(colors) = c( 'High-Visibility Crosswalk','Interim Intersection Tightening','Leading Pedestrian Interval','Paddle Sign','Pedestrian-Activated Flashing Beacon','Pedestrian Refuge Island','Scramble Crosswalk')
infrastructure$Type
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
